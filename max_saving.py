# -*- coding: utf-8 -*-
"""max_saving.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Fw-ak7dh89glg1Uv_7NVDOvuoMFIoYQS
"""

import numpy as np#numpy

def maximum_saving(input_network: str) -> int:
    # Parsing the network inputs into a NumPy array
    network = np.array([[int(x) if x.isdigit() else -1 for x in row.split(",")] for row in input_network.splitlines()])

    # Initializing variables for tracking savings and remaining edges
    total_saving = 0
    remaining_edges = np.ones_like(network, dtype=bool)
    edges_tried = set()

    # Recursively try removing edges while maintaining connectivity
    def try_remove(i, j):
        nonlocal total_saving

        # Check if edge is within bounds and hasn't been tried yet
        if 0 <= i < network.shape[0] and 0 <= j < network.shape[1] and (i, j) not in edges_tried:
            edges_tried.add((i, j))

            # Temporarily remove the edge
            remaining_edges[i, j] = False
            remaining_edges[j, i] = False

            # Check if the network is still connected using DFS
            if dfs_connected(network, remaining_edges):
                # If connected, add the edge's cost (if positive) to total savings
                if network[i, j] > 0:  # Consider only positive edge costs
                    total_saving += network[i, j]

                # Try removing other edges recursively
                for k in range(network.shape[0]):
                    if remaining_edges[i, k]:
                        try_remove(i, k)
                    if remaining_edges[j, k]:
                        try_remove(j, k)

            # Restore the edge for further exploration
            remaining_edges[i, j] = True
            remaining_edges[j, i] = True

    # Depth-first search (DFS) to check connectivity
    def dfs_connected(graph, remaining_edges):
        visited = set()

        def dfs(node):
            visited.add(node)
            for i in range(graph.shape[0]):
                if i != node and graph[node, i] != -1 and remaining_edges[node, i] and i not in visited:
                    dfs(i)

        dfs(0)
        return len(visited) == graph.shape[0]

    # Start removing edges from all nodes
    for i in range(network.shape[0]):
        for j in range(i + 1, network.shape[1]):
            if network[i, j] != -1:  # Consider only non-empty edges
                try_remove(i, j)

    return total_saving

# Test case

input_network = '''-,14,10,19,-,-,-
14,-,-,15,18,-,-
10,-,-,26,,29,-
19,15,26,-,16,17,21
-,18,-,16,-,-,9
-,-,29,17,-,-,25
-,-,-,21,9,25,-
'''
max_saving = maximum_saving(input_network)
print(max_saving)